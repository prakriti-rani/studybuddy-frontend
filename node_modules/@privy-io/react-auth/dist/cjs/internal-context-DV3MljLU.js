"use strict";var e,t=require("ofetch"),r=require("react");class i extends Error{toString(){return`${this.type}${this.privyErrorCode?`-${this.privyErrorCode}`:""}: ${this.message}${this.cause?` [cause: ${this.cause}]`:""}`}constructor(e,t,r){super(e),t instanceof Error&&(this.cause=t),this.privyErrorCode=r}}class a extends i{constructor(e,t,r,i,a,s){super(r,i,a),this.type=e,this.status=t,this.data=s}}class s extends i{constructor(e,t,r){super(e,t,r),this.type="client_error"}}const n=e=>e instanceof i?e:e instanceof Error?new s(e.message,e):new s(`Internal error: ${e}`);var o=((e={}).OAUTH_ACCOUNT_SUSPENDED="oauth_account_suspended",e.MISSING_OR_INVALID_PRIVY_APP_ID="missing_or_invalid_privy_app_id",e.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID="missing_or_invalid_privy_account_id",e.MISSING_OR_INVALID_TOKEN="missing_or_invalid_token",e.INVALID_DATA="invalid_data",e.INVALID_CAPTCHA="invalid_captcha",e.LINKED_TO_ANOTHER_USER="linked_to_another_user",e.CANNOT_LINK_MORE_OF_TYPE="cannot_link_more_of_type",e.FAILED_TO_LINK_ACCOUNT="failed_to_link_account",e.FAILED_TO_UPDATE_ACCOUNT="failed_to_update_account",e.USER_EXITED_UPDATE_FLOW="exited_update_flow",e.ALLOWLIST_REJECTED="allowlist_rejected",e.OAUTH_USER_DENIED="oauth_user_denied",e.OAUTH_UNEXPECTED="oauth_unexpected",e.UNKNOWN_AUTH_ERROR="unknown_auth_error",e.USER_EXITED_AUTH_FLOW="exited_auth_flow",e.USER_EXITED_LINK_FLOW="exited_link_flow",e.USER_EXITED_SET_PASSWORD_FLOW="user_exited_set_password_flow",e.MUST_BE_AUTHENTICATED="must_be_authenticated",e.UNKNOWN_CONNECT_WALLET_ERROR="unknown_connect_wallet_error",e.GENERIC_CONNECT_WALLET_ERROR="generic_connect_wallet_error",e.CLIENT_REQUEST_TIMEOUT="client_request_timeout",e.INVALID_CREDENTIALS="invalid_credentials",e.MISSING_MFA_CREDENTIALS="missing_or_invalid_mfa",e.UNKNOWN_MFA_ERROR="unknown_mfa_error",e.EMBEDDED_WALLET_ALREADY_EXISTS="embedded_wallet_already_exists",e.EMBEDDED_WALLET_NOT_FOUND="embedded_wallet_not_found",e.EMBEDDED_WALLET_CREATE_ERROR="embedded_wallet_create_error",e.UNKNOWN_EMBEDDED_WALLET_ERROR="unknown_embedded_wallet_error",e.EMBEDDED_WALLET_PASSWORD_UNCONFIRMED="embedded_wallet_password_unconfirmed",e.EMBEDDED_WALLET_PASSWORD_ALREADY_EXISTS="embedded_wallet_password_already_exists",e.EMBEDDED_WALLET_RECOVERY_ALREADY_EXISTS="embedded_wallet_recovery_already_exists",e.TRANSACTION_FAILURE="transaction_failure",e.UNSUPPORTED_CHAIN_ID="unsupported_chain_id",e.NOT_SUPPORTED="not_supported",e.CAPTCHA_TIMEOUT="captcha_timeout",e.INVALID_MESSAGE="invalid_message",e.UNABLE_TO_SIGN="unable_to_sign",e.CAPTCHA_FAILURE="captcha_failure",e.CAPTCHA_DISABLED="captcha_disabled",e.SESSION_STORAGE_UNAVAILABLE="session_storage_unavailable",e.TOO_MANY_REQUESTS="too_many_requests",e.USER_LIMIT_REACHED="max_accounts_reached",e.DISALLOWED_LOGIN_METHOD="disallowed_login_method",e.DISALLOWED_PLUS_EMAIL="disallowed_plus_email",e.PASSKEY_NOT_ALLOWED="passkey_not_allowed",e.USER_DOES_NOT_EXIST="user_does_not_exist",e.INSUFFICIENT_BALANCE="insufficient_balance",e.ACCOUNT_TRANSFER_REQUIRED="account_transfer_required",e);const _=()=>{throw Error("You need to wrap your application with the <PrivyProvider> initialized with your app id.")},l=/*#__PURE__*/r.createContext({setAuthenticated:_,setUser:_,isNewUserThisSession:!1,walletConnectionStatus:null,connectors:[],solanaWallets:[],rpcConfig:{rpcUrls:{}},showFiatPrices:!0,chains:[],clientAnalyticsId:null,pendingTransaction:null,client:null,appId:"notAdded",customAuthStatus:{status:"not-enabled"},hideWalletUIs:{current:!1},nativeTokenSymbolForChainId:_,initializeWalletProxy:_,getAuthMeta:_,getAuthFlow:_,closePrivyModal:_,openPrivyModal:_,connectWallet:_,initLoginWithWallet:_,loginWithWallet:_,initLoginWithFarcaster:_,loginWithFarcaster:_,loginWithCode:_,initLoginWithEmail:_,initLoginWithSms:_,initUpdateEmail:_,initUpdatePhone:_,resendEmailCode:_,resendSmsCode:_,initLoginWithHeadlessOAuth:_,loginWithHeadlessOAuth:_,crossAppAuthFlow:_,initLoginWithOAuth:_,recoveryOAuthFlow:_,loginWithOAuth:_,passkeyAuthState:{status:"initial"},setPasskeyAuthState:_,initSignupWithPasskey:_,signupWithPasskey:_,initLoginWithPasskey:_,loginWithPasskey:_,initLinkWithPasskey:_,linkWithPasskey:_,refreshSessionAndUser:_,loginWithGuestAccountFlow:_,walletProxy:null,createAnalyticsEvent:_,acceptTerms:_,getUsdTokenPrice:_,getUsdPriceForSol:_,getSplTokenMetadata:_,recoverPrimaryWallet:_,updateWallets:_,fundWallet:_,openModal:_,setReadyToTrue:_,requestFarcasterSignerStatus:_,initLoginWithTelegram:_,loginWithTelegram:_,generateSiweMessage:_,generateSiweMessageForSmartWallet:_,linkWithSiwe:_,linkSmartWallet:_,delegateWallet:_,revokeDelegatedWallets:_,embeddedSolanaWallets:null,createEmbeddedSolanaWallet:_,exportSolanaWallet:_,solanaSignMessage:_,sendSolanaTransaction:_,signSolanaTransaction:_,connectCoinbaseSmartWallet:_,initiateAccountTransfer:_,emailOtpState:{status:"initial"},setEmailOtpState:_,smsOtpState:{status:"initial"},setSmsOtpState:_,siweState:{status:"initial"},setSiweState:_,oAuthState:{status:"initial"},setOAuthState:_,telegramAuthState:{status:"initial"},setTelegramAuthState:_,isHeadlessOAuthLoading:!1,isHeadlessSigning:_});exports.InternalPrivyContext=l,exports.PrivyApiError=a,exports.PrivyClientError=s,exports.PrivyConnectorError=class extends i{constructor(e,t,r){super(e,t,r),this.type="connector_error"}},exports.PrivyEmbeddedWalletError=class extends s{constructor(e="Embedded wallet error",t){super(e,t,"unknown_embedded_wallet_error")}},exports.PrivyError=i,exports.PrivyErrorCode=o,exports.PrivyNotReadyError=class extends s{constructor(){super("Method called before `ready`. Ensure you wait until `ready` is true before calling.")}},exports.PrivyTimeoutError=class extends s{constructor(){super("Request timed out",void 0,"client_request_timeout")}},exports.PrivyUnauthenticatedError=class extends s{constructor(e="User must be authenticated"){super(e,void 0,"must_be_authenticated")}},exports.PrivyUserLimitReachedError=class extends s{constructor(e){super("This application is in development mode and must be upgraded to production to log in new users.",e,"max_accounts_reached")}},exports.formatApiError=e=>{if(e instanceof i)return e;if(!(e instanceof t.FetchError))return n(e);if(!e.response)return new a("api_error",null,e.message,e);let{type:r,message:s,error:o,code:_}=e.data;return new a(r||"ApiError",e.response.status,s||o,e,_,e.data)},exports.formatPrivyError=n,exports.notImplemented=_,exports.notImplementedWithMessage=e=>()=>{throw Error(e.trim())},exports.usePrivyInternal=()=>r.useContext(l);
