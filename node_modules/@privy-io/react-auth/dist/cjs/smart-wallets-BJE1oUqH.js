"use strict";var e=require("react"),t=require("viem"),n=require("./useWallets-Dmyb5a0t.js"),r=require("./internal-context-DV3MljLU.js"),a=require("./getPublicClient-hVv5ZSWd.js"),i=require("./getEmbeddedConnectedWallet-DTU4T9TJ.js"),s=require("permissionless"),o=require("permissionless/accounts"),l=require("permissionless/clients/pimlico"),c=require("viem/account-abstraction"),u=require("@privy-io/js-sdk-core");let d={address:c.entryPoint06Address,version:"0.6"},p={address:c.entryPoint07Address,version:"0.7"},y=({owner:e,smartWalletType:t,publicClient:n})=>{switch(t){case u.SAFE:return o.toSafeSmartAccount({client:n,entryPoint:p,owners:[e],version:"1.4.1"});case u.KERNEL:return o.toEcdsaKernelSmartAccount({client:n,version:"0.3.1",entryPoint:p,owners:[e]});case u.BICONOMY:return o.toBiconomySmartAccount({client:n,owners:[e],entryPoint:d});case u.LIGHT_ACCOUNT:return o.toLightSmartAccount({client:n,entryPoint:d,owner:e,version:"1.1.0"});case u.COINBASE_SMART_WALLET:return async function({client:e,owner:t}){let[n]=await t.request({method:"eth_accounts"});if(!n)throw Error("Unable to request embedded owner for eth_accounts");return await c.toCoinbaseSmartAccount({client:e,owners:[{type:"local",source:"privy",address:n,sign:async({hash:e})=>await t.request({method:"secp256k1_sign",params:[e]})}]})}({client:n,owner:e});case u.THIRDWEB:return o.toThirdwebSmartAccount({client:n,entryPoint:p,owner:e});default:throw Error(`Invalid smart account type: ${t}.`)}},m=["rpc.zerodev.app","public.pimlico.io","api.pimlico.io"];const E=async({owner:e,smartWalletType:n,chain:r,publicClient:a,bundlerUrl:i,paymasterUrl:o,paymasterContext:c})=>{let u=await y({owner:e,smartWalletType:n,publicClient:a}),d=l.createPimlicoClient({transport:t.http(i),entryPoint:u.entryPoint}),p=o?l.createPimlicoClient({transport:t.http(o),entryPoint:u.entryPoint}):void 0;return s.createSmartAccountClient({account:u,chain:r,paymaster:p,paymasterContext:c,bundlerTransport:t.http(i),userOperation:{estimateFeesPerGas:async()=>{if(m.some((e=>i.includes(e))))return await d.getUserOperationGasPrice().then((e=>e.fast));{let e=await a.estimateFeesPerGas(),t=i.includes("api.developer.coinbase.com")?175n:150n;return{...e,maxFeePerGas:e.maxFeePerGas*t/100n,maxPriorityFeePerGas:e.maxPriorityFeePerGas*t/100n}}}}})};const g=({calls:e,chain:t,maxPriorityFeePerGas:n,maxFeePerGas:r,nonce:a})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:t.id,nonce:a,maxFeePerGas:r,maxPriorityFeePerGas:n}))),I=async({chain:e,paymasterContext:n,embeddedWallet:i,user:s,smartWalletsConfig:o,rpcConfig:l,privyAppId:c})=>{if(!o?.enabled||!s||!i)return;let u=await i.getEthereumProvider(),d=o?.configuredNetworks.find((t=>t.chainId===`eip155:${e.id}`));if(!d)throw new r.PrivyClientError(`The chain ${e.name} (eip155:${e.id}) must be configured in the smart wallet configuration in your dashboard`);let p=s.smartWallet?.smartWalletType??o.smartWalletType,y=a.getJsonRpcEndpointFromChain(e,l,c),m=t.createPublicClient({chain:e,transport:t.http(y)}),g=n??d.paymasterContext,I=await E({owner:u,smartWalletType:p,chain:e,publicClient:m,paymasterContext:g,...d});if(!I)throw new r.PrivyClientError(`Failed to create smart wallet client for chain ${e.name} (eip155:${e.id})`);return I};exports.callsToTransactionRequests=g,exports.getSmartWalletClient=I,exports.useSmartWalletsUIWrapper=()=>{let{hideWalletUIs:e,openPrivyModal:t,isHeadlessSigning:a}=r.usePrivyInternal(),{setModalData:i}=n.usePrivyModal(),{user:s}=n.usePrivyContext();return{wrapSmartAccountClientWithUIs:r=>({...r,sendTransaction:async(o,l)=>{if(a({showWalletUIs:l?.uiOptions?.showWalletUIs}))return e.current=!0,await r.sendTransaction(o).finally((()=>e.current=!1));let c=[];"calls"in o&&void 0!==o.calls?c=[...o.calls]:"to"in o&&(c=[{to:o.to,value:o.value||BigInt(0),data:o.data||"0x"}]);let u=async()=>{if(!r.paymaster)return!1;let{paymasterAndData:e,paymasterData:t}=await r.prepareUserOperation({calls:c,maxFeePerGas:o.maxFeePerGas,maxPriorityFeePerGas:o.maxPriorityFeePerGas,nonce:o.nonce?BigInt(o.nonce):void 0});return Number(e??t??0)>0};return new Promise((async(a,d)=>{e.current=!0;let{entropyId:p,entropyIdVerifier:y}=n.getEntropyDetailsFromUser(s);i({connectWallet:{entropyId:p,entropyIdVerifier:y,onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:g({calls:c,chain:r.chain,maxPriorityFeePerGas:o.maxPriorityFeePerGas,maxFeePerGas:o.maxFeePerGas,nonce:o.nonce?BigInt(o.nonce):void 0}),entropyId:p,entropyIdVerifier:y,transactingWallet:{address:r.account.address,walletIndex:null},getIsSponsored:u,signOnly:!1,onConfirm:()=>r.sendTransaction(o),onSuccess:e=>a(e.hash),onFailure:d,uiOptions:l?.uiOptions??{}}}),t(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))},signMessage:async(o,l)=>a({showWalletUIs:l?.uiOptions?.showWalletUIs})?(e.current=!0,await r.signMessage(o).finally((()=>e.current=!1))):new Promise((async(a,c)=>{let{entropyId:u,entropyIdVerifier:d}=n.getEntropyDetailsFromUser(s);e.current=!0,i({connectWallet:{entropyId:u,entropyIdVerifier:d,onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof o.message?o.message:o.message.raw.toString(),confirmAndSign:()=>r.signMessage(o),onSuccess:e=>a(e),onFailure:c,uiOptions:l?.uiOptions??{}}}),t(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1})),signTypedData:async(o,l)=>a({showWalletUIs:l?.uiOptions?.showWalletUIs})?(e.current=!0,await r.signTypedData(o).finally((()=>e.current=!1))):new Promise((async(a,c)=>{e.current=!0;let{entropyId:u,entropyIdVerifier:d}=n.getEntropyDetailsFromUser(s);i({connectWallet:{entropyId:u,entropyIdVerifier:d,onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:o,confirmAndSign:()=>r.signTypedData(o),onSuccess:e=>a(e),onFailure:c,uiOptions:l?.uiOptions??{}}}),t(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))})}},exports.useSmartWalletsWrapper=({clientConfig:t,smartWalletsConfig:a})=>{let{hideWalletUIs:s,openPrivyModal:o,appId:l,isHeadlessSigning:c}=r.usePrivyInternal(),u=n.useAppConfig(),{setModalData:d}=n.usePrivyModal(),{user:p}=n.usePrivyContext(),{chains:y}=n.useAppConfig(),{chainId:m,clients:E,setChainId:C,chainIdState:h}=(()=>{let t=e.useRef(),[n,r]=e.useState();return{clients:e.useRef({}),setChainId:e=>{t.current=e,r(e)},chainId:t,chainIdState:n}})(),f=y.find((e=>e.id===h)),{wallets:w}=n.useWallets(),P=e.useCallback((async()=>m.current),[m]),S=e.useCallback((async({id:e})=>{if(!E.current[e]){let n=i.getEmbeddedConnectedWallet(w),r=await I({chain:y.find((t=>t.id===e)),embeddedWallet:n,user:p,paymasterContext:t?.paymasterContext,smartWalletsConfig:a,rpcConfig:u.rpcConfig,privyAppId:l});r&&(E.current[e]=r)}C(e)}),[y,t,w,p,a]);return{wrapSmartAccountClient:e=>{E.current[e.chain.id]=e,h||C(e.chain.id);return{...e,sendTransaction:async(e,t)=>{let a=E.current[m.current];if(!a)throw new r.PrivyClientError(`Smart wallet client for chain (eip155:${m.current}) not found`);if(delete e.account,c({showWalletUIs:t?.uiOptions?.showWalletUIs}))return s.current=!0,await a.sendTransaction(e).finally((()=>s.current=!1));let i=[];"calls"in e&&void 0!==e.calls?i=[...e.calls]:"to"in e&&(i=[{to:e.to,value:e.value||BigInt(0),data:e.data||"0x"}]);let l=async()=>{if(!a.paymaster)return!1;let{paymasterAndData:t,paymasterData:n}=await a.prepareUserOperation({calls:i,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0});return Number(t??n??0)>0};return new Promise((async(r,c)=>{s.current=!0;let{entropyId:u,entropyIdVerifier:y}=n.getEntropyDetailsFromUser(p);d({connectWallet:{entropyId:u,entropyIdVerifier:y,onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:g({calls:i,chain:a.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),entropyId:u,entropyIdVerifier:y,transactingWallet:{address:a.account.address,walletIndex:null},getIsSponsored:l,signOnly:!1,onConfirm:()=>a.sendTransaction(e),onSuccess:e=>r(e.hash),onFailure:c,uiOptions:t?.uiOptions??{}}}),o(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{s.current=!1}))},signMessage:async(e,t)=>{let a=E.current[m.current];if(!a)throw new r.PrivyClientError(`Smart wallet client for chain (eip155:${m.current}) not found`);return c({showWalletUIs:t?.uiOptions?.showWalletUIs})?(s.current=!0,await a.signMessage(e).finally((()=>s.current=!1))):new Promise((async(r,i)=>{let{entropyId:l,entropyIdVerifier:c}=n.getEntropyDetailsFromUser(p);s.current=!0,d({connectWallet:{entropyId:l,entropyIdVerifier:c,onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof e.message?e.message:e.message.raw.toString(),confirmAndSign:()=>a.signMessage(e),onSuccess:e=>r(e),onFailure:i,uiOptions:t?.uiOptions??{}}}),o(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{s.current=!1}))},signTypedData:async(e,t)=>{let a=E.current[m.current];if(!a)throw new r.PrivyClientError(`Smart wallet client for chain (eip155:${m.current}) not found`);return delete e.account,c({showWalletUIs:t?.uiOptions?.showWalletUIs})?(s.current=!0,await a.signTypedData(e).finally((()=>s.current=!1))):new Promise((async(r,i)=>{s.current=!0;let{entropyId:l,entropyIdVerifier:c}=n.getEntropyDetailsFromUser(p);d({connectWallet:{entropyId:l,entropyIdVerifier:c,onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>a.signTypedData(e),onSuccess:e=>r(e),onFailure:i,uiOptions:t?.uiOptions??{}}}),o(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{s.current=!1}))},getChainId:P,chain:f,switchChain:S}}}};
