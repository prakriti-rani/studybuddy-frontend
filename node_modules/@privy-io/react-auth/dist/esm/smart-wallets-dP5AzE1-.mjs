import{useRef as e,useState as n,useCallback as t}from"react";import{http as a,createPublicClient as r}from"viem";import{q as i,u as s,r as o,E as l,ab as c,M as d}from"./useWallets-DTpjk5Rk.mjs";import{P as u,u as p}from"./internal-context-mSHyF0Gq.mjs";import{a as m}from"./getPublicClient-wHgCncHx.mjs";import{g as y}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import{createSmartAccountClient as E}from"permissionless";import{toThirdwebSmartAccount as g,toLightSmartAccount as f,toBiconomySmartAccount as I,toEcdsaKernelSmartAccount as h,toSafeSmartAccount as w}from"permissionless/accounts";import{createPimlicoClient as C}from"permissionless/clients/pimlico";import{toCoinbaseSmartAccount as P,entryPoint06Address as T,entryPoint07Address as D}from"viem/account-abstraction";import{THIRDWEB as _,COINBASE_SMART_WALLET as N,LIGHT_ACCOUNT as W,BICONOMY as S,KERNEL as v,SAFE as F}from"@privy-io/js-sdk-core";let x={address:T,version:"0.6"},G={address:D,version:"0.7"},O=({owner:e,smartWalletType:n,publicClient:t})=>{switch(n){case F:return w({client:t,entryPoint:G,owners:[e],version:"1.4.1"});case v:return h({client:t,version:"0.3.1",entryPoint:G,owners:[e]});case S:return I({client:t,owners:[e],entryPoint:x});case W:return f({client:t,entryPoint:x,owner:e,version:"1.1.0"});case N:return async function({client:e,owner:n}){let[t]=await n.request({method:"eth_accounts"});if(!t)throw Error("Unable to request embedded owner for eth_accounts");return await P({client:e,owners:[{type:"local",source:"privy",address:t,sign:async({hash:e})=>await n.request({method:"secp256k1_sign",params:[e]})}]})}({client:t,owner:e});case _:return g({client:t,entryPoint:G,owner:e});default:throw Error(`Invalid smart account type: ${n}.`)}},M=["rpc.zerodev.app","public.pimlico.io","api.pimlico.io"];const A=async({owner:e,smartWalletType:n,chain:t,publicClient:r,bundlerUrl:i,paymasterUrl:s,paymasterContext:o})=>{let l=await O({owner:e,smartWalletType:n,publicClient:r}),c=C({transport:a(i),entryPoint:l.entryPoint}),d=s?C({transport:a(s),entryPoint:l.entryPoint}):void 0;return E({account:l,chain:t,paymaster:d,paymasterContext:o,bundlerTransport:a(i),userOperation:{estimateFeesPerGas:async()=>{if(M.some((e=>i.includes(e))))return await c.getUserOperationGasPrice().then((e=>e.fast));{let e=await r.estimateFeesPerGas(),n=i.includes("api.developer.coinbase.com")?175n:150n;return{...e,maxFeePerGas:e.maxFeePerGas*n/100n,maxPriorityFeePerGas:e.maxPriorityFeePerGas*n/100n}}}}})};const U=({calls:e,chain:n,maxPriorityFeePerGas:t,maxFeePerGas:a,nonce:r})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:n.id,nonce:r,maxFeePerGas:a,maxPriorityFeePerGas:t}))),L=async({chain:e,paymasterContext:n,embeddedWallet:t,user:i,smartWalletsConfig:s,rpcConfig:o,privyAppId:l})=>{if(!s?.enabled||!i||!t)return;let c=await t.getEthereumProvider(),d=s?.configuredNetworks.find((n=>n.chainId===`eip155:${e.id}`));if(!d)throw new u(`The chain ${e.name} (eip155:${e.id}) must be configured in the smart wallet configuration in your dashboard`);let p=i.smartWallet?.smartWalletType??s.smartWalletType,y=m(e,o,l),E=r({chain:e,transport:a(y)}),g=n??d.paymasterContext,f=await A({owner:c,smartWalletType:p,chain:e,publicClient:E,paymasterContext:g,...d});if(!f)throw new u(`Failed to create smart wallet client for chain ${e.name} (eip155:${e.id})`);return f},b=({clientConfig:a,smartWalletsConfig:r})=>{let{hideWalletUIs:m,openPrivyModal:E,appId:g,isHeadlessSigning:f}=p(),I=i(),{setModalData:h}=s(),{user:w}=o(),{chains:C}=i(),{chainId:P,clients:T,setChainId:D,chainIdState:_}=(()=>{let t=e(),[a,r]=n();return{clients:e({}),setChainId:e=>{t.current=e,r(e)},chainId:t,chainIdState:a}})(),N=C.find((e=>e.id===_)),{wallets:W}=l(),S=t((async()=>P.current),[P]),v=t((async({id:e})=>{if(!T.current[e]){let n=y(W),t=await L({chain:C.find((n=>n.id===e)),embeddedWallet:n,user:w,paymasterContext:a?.paymasterContext,smartWalletsConfig:r,rpcConfig:I.rpcConfig,privyAppId:g});t&&(T.current[e]=t)}D(e)}),[C,a,W,w,r]);return{wrapSmartAccountClient:e=>{T.current[e.chain.id]=e,_||D(e.chain.id);return{...e,sendTransaction:async(e,n)=>{let t=T.current[P.current];if(!t)throw new u(`Smart wallet client for chain (eip155:${P.current}) not found`);if(delete e.account,f({showWalletUIs:n?.uiOptions?.showWalletUIs}))return m.current=!0,await t.sendTransaction(e).finally((()=>m.current=!1));let a=[];"calls"in e&&void 0!==e.calls?a=[...e.calls]:"to"in e&&(a=[{to:e.to,value:e.value||BigInt(0),data:e.data||"0x"}]);let r=async()=>{if(!t.paymaster)return!1;let{paymasterAndData:n,paymasterData:r}=await t.prepareUserOperation({calls:a,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0});return Number(n??r??0)>0};return new Promise((async(i,s)=>{m.current=!0;let{entropyId:o,entropyIdVerifier:l}=c(w);h({connectWallet:{entropyId:o,entropyIdVerifier:l,onCompleteNavigateTo:d.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:U({calls:a,chain:t.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),entropyId:o,entropyIdVerifier:l,transactingWallet:{address:t.account.address,walletIndex:null},getIsSponsored:r,signOnly:!1,onConfirm:()=>t.sendTransaction(e),onSuccess:e=>i(e.hash),onFailure:s,uiOptions:n?.uiOptions??{}}}),E(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{m.current=!1}))},signMessage:async(e,n)=>{let t=T.current[P.current];if(!t)throw new u(`Smart wallet client for chain (eip155:${P.current}) not found`);return f({showWalletUIs:n?.uiOptions?.showWalletUIs})?(m.current=!0,await t.signMessage(e).finally((()=>m.current=!1))):new Promise((async(a,r)=>{let{entropyId:i,entropyIdVerifier:s}=c(w);m.current=!0,h({connectWallet:{entropyId:i,entropyIdVerifier:s,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof e.message?e.message:e.message.raw.toString(),confirmAndSign:()=>t.signMessage(e),onSuccess:e=>a(e),onFailure:r,uiOptions:n?.uiOptions??{}}}),E(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{m.current=!1}))},signTypedData:async(e,n)=>{let t=T.current[P.current];if(!t)throw new u(`Smart wallet client for chain (eip155:${P.current}) not found`);return delete e.account,f({showWalletUIs:n?.uiOptions?.showWalletUIs})?(m.current=!0,await t.signTypedData(e).finally((()=>m.current=!1))):new Promise((async(a,r)=>{m.current=!0;let{entropyId:i,entropyIdVerifier:s}=c(w);h({connectWallet:{entropyId:i,entropyIdVerifier:s,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>t.signTypedData(e),onSuccess:e=>a(e),onFailure:r,uiOptions:n?.uiOptions??{}}}),E(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{m.current=!1}))},getChainId:S,chain:N,switchChain:v}}}},R=()=>{let{hideWalletUIs:e,openPrivyModal:n,isHeadlessSigning:t}=p(),{setModalData:a}=s(),{user:r}=o();return{wrapSmartAccountClientWithUIs:i=>({...i,sendTransaction:async(s,o)=>{if(t({showWalletUIs:o?.uiOptions?.showWalletUIs}))return e.current=!0,await i.sendTransaction(s).finally((()=>e.current=!1));let l=[];"calls"in s&&void 0!==s.calls?l=[...s.calls]:"to"in s&&(l=[{to:s.to,value:s.value||BigInt(0),data:s.data||"0x"}]);let u=async()=>{if(!i.paymaster)return!1;let{paymasterAndData:e,paymasterData:n}=await i.prepareUserOperation({calls:l,maxFeePerGas:s.maxFeePerGas,maxPriorityFeePerGas:s.maxPriorityFeePerGas,nonce:s.nonce?BigInt(s.nonce):void 0});return Number(e??n??0)>0};return new Promise((async(t,p)=>{e.current=!0;let{entropyId:m,entropyIdVerifier:y}=c(r);a({connectWallet:{entropyId:m,entropyIdVerifier:y,onCompleteNavigateTo:d.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:U({calls:l,chain:i.chain,maxPriorityFeePerGas:s.maxPriorityFeePerGas,maxFeePerGas:s.maxFeePerGas,nonce:s.nonce?BigInt(s.nonce):void 0}),entropyId:m,entropyIdVerifier:y,transactingWallet:{address:i.account.address,walletIndex:null},getIsSponsored:u,signOnly:!1,onConfirm:()=>i.sendTransaction(s),onSuccess:e=>t(e.hash),onFailure:p,uiOptions:o?.uiOptions??{}}}),n(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))},signMessage:async(s,o)=>t({showWalletUIs:o?.uiOptions?.showWalletUIs})?(e.current=!0,await i.signMessage(s).finally((()=>e.current=!1))):new Promise((async(t,l)=>{let{entropyId:u,entropyIdVerifier:p}=c(r);e.current=!0,a({connectWallet:{entropyId:u,entropyIdVerifier:p,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof s.message?s.message:s.message.raw.toString(),confirmAndSign:()=>i.signMessage(s),onSuccess:e=>t(e),onFailure:l,uiOptions:o?.uiOptions??{}}}),n(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1})),signTypedData:async(s,o)=>t({showWalletUIs:o?.uiOptions?.showWalletUIs})?(e.current=!0,await i.signTypedData(s).finally((()=>e.current=!1))):new Promise((async(t,l)=>{e.current=!0;let{entropyId:u,entropyIdVerifier:p}=c(r);a({connectWallet:{entropyId:u,entropyIdVerifier:p,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:s,confirmAndSign:()=>i.signTypedData(s),onSuccess:e=>t(e),onFailure:l,uiOptions:o?.uiOptions??{}}}),n(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))})}};export{b as a,U as c,L as g,R as u};
