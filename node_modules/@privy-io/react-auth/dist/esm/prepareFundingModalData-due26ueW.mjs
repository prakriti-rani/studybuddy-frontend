import{b as e,j as t,l as n,u as a,P as s}from"./internal-context-mSHyF0Gq.mjs";import r from"eventemitter3";import{ProviderErrors as o}from"@privy-io/js-sdk-core";import{d as i,E as c,u as l,M as d,al as u,am as h,an as p,ao as g,N as f,ap as m,T as y,aq as C,U as w,ar as E,Q as b,as as S,ah as T,at as A,X as v,au as _}from"./useWallets-DTpjk5Rk.mjs";import{createContext as D,useEffect as R,useContext as x,useRef as O,useCallback as I,useState as W}from"react";import{jsx as N}from"react/jsx-runtime";import{ofetch as F}from"ofetch";class U{get(e){let t=localStorage.getItem(e);return null===t?void 0:JSON.parse(t)}put(e,t){void 0!==t?localStorage.setItem(e,JSON.stringify(t)):this.del(e)}del(e){localStorage.removeItem(e)}getKeys(){return Object.entries(localStorage).map((([e])=>e))}}function M(){try{let e="privy:__session_storage__test",t=new U;return t.put(e,"blobby"),t.del(e),!0}catch(e){return!1}}var P="undefined"!=typeof window&&window.localStorage?new U:new class{get(e){return this._cache[e]}put(e,t){void 0!==t?this._cache[e]=t:this.del(e)}del(e){delete this._cache[e]}getKeys(){return Object.keys(this._cache)}constructor(){this._cache={}}};class L extends e{constructor(){super("Wallet timeout"),this.type="wallet_error"}}class k extends e{constructor(){super("User rejected connection"),this.type="wallet_error"}}const B=t=>t instanceof e?t:t?.code?new $(t):new e("Unknown connector error",t);class j extends t{constructor(e,t,n){super(e),this.type="provider_error",this.code=t,this.data=n}}class $ extends j{constructor(e){super(e.message,e.code,e.data);let t=Object.values(o).find((t=>t.eipCode===e.code));this.details=t||o.UNKNOWN_ERROR,-32002===e.code&&(e.message?.includes("already pending for origin")?e.message?.includes("wallet_requestPermissions")?this.details=o.E32002_CONNECTION_ALREADY_PENDING:this.details=o.E32002_REQUEST_ALREADY_PENDING:e.message?.includes("Already processing")&&e.message.includes("eth_requestAccounts")&&(this.details=o.E32002_WALLET_LOCKED))}}const q={ERROR_USER_EXISTS:{message:"User already exists for this address",detail:"Try another address!",retryable:!1},ERROR_TIMED_OUT:{message:"Wallet request timed out",detail:"Please try connecting again.",retryable:!0},ERROR_WALLET_CONNECTION:{message:"Could not log in with wallet",detail:"Please try connecting again.",retryable:!0},ERROR_USER_REJECTED_CONNECTION:{message:"You rejected the request",detail:"Please try connecting again.",retryable:!0},ERROR_USER_LIMIT_REACHED:{message:"Unable to link",detail:"You've reached the maximum number of linked wallets.",retryable:!1},...o};class K extends r{constructor(e){super(),this.walletClientType=e,this.connected=!1,this.initialized=!1}}const z=()=>{let e=P.get(i);return e&&Array.isArray(e)&&e.map((e=>(e=>e&&"string"==typeof e.address&&"string"==typeof e.connectorType&&"string"==typeof e.walletClientType&&"number"==typeof e.connectedAt)(e))).every(Boolean)?e:[]};let G=["phantom","glow","solflare","backpack","okx_wallet"];function Y(e){return"solana"===e.chainType}function H(e){return"solana"===e.type}class J extends K{get isInstalled(){return"Installed"===this.adapter.readyState}buildConnectedWallet(e,t){let a,s,r,o;if("Installed"!==e.readyState||!e.publicKey)throw Error("Wallet is not connected.");return"signMessage"in e&&(a=async(...t)=>{if(!e.connected)throw Error("Wallet is not connected.");return await e.signMessage(t[0])}),"sendTransaction"in e&&(s=async(...t)=>await e.sendTransaction(t[0],t[1],t[2])),"signTransaction"in e&&(r=async t=>await e.signTransaction(t)),"signAllTransactions"in e&&(o=async t=>await e.signAllTransactions(t)),{type:"solana",address:e.publicKey.toBase58(),meta:t,imported:!1,connectedAt:Date.now(),walletClientType:this.walletClientType,connectorType:this.connectorType,isConnected:async()=>e.connected,disconnect:()=>{try{e.disconnect()}catch(e){console.error("Wallet does not support programmatic disconnect")}},getProvider:n(`${this.walletClientType||""} wallet does not support 'getProvider'`),signMessage:a??n(`${this.walletClientType||""} wallet does not support 'signMessage'`),sendTransaction:s??n(`${this.walletClientType||""} wallet does not support 'sendTransaction'`),signTransaction:r??n(`${this.walletClientType||""} wallet does not support 'signTransaction'`),signAllTransactions:o??n(`${this.walletClientType||""} wallet does not support 'signAllTransactions'`)}}async syncAccounts(){if("Installed"===this.adapter.readyState&&this.adapter.publicKey){let e={name:this.walletBranding.name,icon:"string"==typeof this.walletBranding.icon?this.walletBranding.icon:void 0,id:this.walletBranding.id};this.wallets.find((e=>this.adapter.publicKey&&e.address===this.adapter.publicKey.toBase58()))||(this.wallets=[this.buildConnectedWallet(this.adapter,e)],this.emit("walletsUpdated"))}else this.wallets.length>0&&(this.wallets=[],this.emit("walletsUpdated"))}get walletBranding(){return{id:this.adapter.name,name:this.adapter.name,icon:this.adapter.icon}}async initialize(){this.subscribeListeners(),await this.syncAccounts(),this.shouldAttemptAutoConnect()&&await this.adapter.autoConnect().catch((()=>{})),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}async getConnectedWallet(){return this.wallets.sort(((e,t)=>t.connectedAt-e.connectedAt))[0]||null}async isConnected(){return this.adapter.connected&&["Installed"].includes(this.adapter.readyState)}subscribeListeners(){this.adapter.addListener("disconnect",this.onDisconnect),this.adapter.addListener("connect",this.onConnect),this.adapter.addListener("error",this.onError),this.adapter.addListener("readyStateChange",this.onReadyStateChange)}unsubscribeListeners(){this.adapter.removeAllListeners()}shouldAttemptAutoConnect(){return!(!this.autoConnectEnabled||!G.includes(this.walletClientType))&&("phantom"!==this.walletClientType||z().some((({walletClientType:e})=>"phantom"===e)))}constructor(e,t){super(function(e){return e.name.toLowerCase().split(" ").join("_")}(e)),this.chainType="solana",this.connectorType="solana_adapter",this.disconnect=()=>{this.adapter.disconnect().then((()=>this.onDisconnect())).catch((e=>console.error("Error disconnecting",e)))},this.promptConnection=async()=>{try{await this.adapter.connect()}catch(e){throw B(e)}},this.onDisconnect=()=>{this.syncAccounts()},this.onConnect=e=>{this.syncAccounts()},this.onError=e=>{this.syncAccounts()},this.onReadyStateChange=e=>{"Installed"!==e&&(this.connected=!1),this.syncAccounts()},this.adapter=e,this.autoConnectEnabled=t,this.wallets=[]}}const Q={login:{onComplete:[],onError:[]},logout:{onSuccess:[]},connectWallet:{onSuccess:[],onError:[]},createWallet:{onSuccess:[],onError:[]},linkAccount:{onSuccess:[],onError:[]},update:{onSuccess:[],onError:[]},configureMfa:{onMfaRequired:[]},setWalletPassword:{onSuccess:[],onError:[]},setWalletRecovery:{onSuccess:[],onError:[]},signMessage:{onSuccess:[],onError:[]},signTypedData:{onSuccess:[],onError:[]},sendTransaction:{onSuccess:[],onError:[]},signTransaction:{onSuccess:[],onError:[]},signSolanaTransaction:{onSuccess:[],onError:[]},signSolanaMessage:{onSuccess:[],onError:[]},sendSolanaTransaction:{onSuccess:[],onError:[]},accessToken:{onAccessTokenGranted:[],onAccessTokenRemoved:[]},oAuthAuthorization:{onOAuthTokenGrant:[]},fundWallet:{onUserExited:[]},fundSolanaWallet:{onUserExited:[]},customAuth:{onAuthenticated:[],onUnauthenticated:[]}},X=/*#__PURE__*/D(void 0);let V=()=>x(X);function Z(e,t){if(!t)return;let n=V().current[e];return R((()=>{for(let[a,s]of Object.entries(t))Object.prototype.hasOwnProperty.call(n,a)||console.warn(`Invalid event type "${a}" for action "${e}"`),n[a]?.push(s);return()=>{for(let[a,s]of Object.entries(t))Object.prototype.hasOwnProperty.call(n,a)||console.warn(`Invalid event type "${a}" for action "${e}"`),n[a]=n[a]?.filter((e=>e!==s))}}),[t])}function ee(e,t,n,...a){for(let s of e.current[t][n])s(...a)}function te(){let e=V();return(t,n,...a)=>ee(e,t,n,...a)}const ne="sdk_fiat_on_ramp_completed_with_status";let ae=/*#__PURE__*/D({plugins:{current:{}}});const se=({children:e})=>{let t=O({});/*#__PURE__*/return N(ae.Provider,{value:{plugins:t},children:e})},re=(...e)=>{let{plugins:t}=x(ae);R((()=>{for(let n of e)t.current[n.id]=n;return()=>{for(let n of e)delete t.current[n.id]}}),[t])},oe=()=>{let{plugins:e}=x(ae);return I((t=>e.current[t]),[e])},ie=Symbol("solana-funding-plugin"),ce=()=>{let{exportSolanaWallet:e,createEmbeddedSolanaWallet:t,solanaWallets:n,embeddedSolanaWallets:s}=a(),{ready:r}=c();return{ready:r,createWallet:t,exportWallet:e,wallets:n.concat(s??[])}};function le(e){let t=new RegExp(RegExp("^eip155:(?<chainId>\\d+)$","gm")),n=t.exec(e)?.groups?.chainId;if(n)return parseInt(n);throw Error("Chain ID not compatible with CAIP-2 format.")}const de=e=>e.filter((e=>"wallets"===e.method||("exchange"===e.method?"coinbase"===e.provider:"card"===e.method||"payment-request"===e.method?"coinbase"===e.provider||"moonpay"===e.provider:(e.method,!1)))),ue="moonpay";function he(e){return parseFloat(e)}function pe(e){return!!e&&void 0!==e.config&&void 0!==e.provider}function ge(e){return!!e&&(void 0!==e.chain||void 0!==e.amount)}function fe(e,t=!1){let[n,s]=W(null),{createAnalyticsEvent:r}=a(),{data:o,navigate:i,setModalData:c}=l(),f=o?.funding,m=O(0);return R((()=>{let n=setInterval((async()=>{if(e)try{let[a]=await async function(e,t){return F(`${t?u:h}/transactions/ext/${e}`,{query:{apiKey:t?p:g}})}(e,t),o="waitingAuthorization"===a.status&&"credit_debit_card"===a.paymentMethod?"pending":a.status;if(["failed","completed","awaitingAuthorization"].includes(o)&&(r({eventName:ne,payload:{status:o,provider:ue,paymentMethod:a.paymentMethod,cardPaymentType:a.cardPaymentType,currency:a.currency?.code,baseCurrencyAmount:a.baseCurrencyAmount,quoteCurrencyAmount:a.quoteCurrencyAmount,feeAmount:a.feeAmount,extraFeeAmount:a.extraFeeAmount,networkFeeAmount:a.networkFeeAmount,isSandbox:t}}),clearInterval(n)),"failed"===o||"serviceFailure"===o)return c({funding:{...f,errorMessage:"Something went wrong adding funds from Moonpay. Please try again or use another method to fund your wallet."}}),void i(d.FUNDING_METHOD_SELECTION_SCREEN);s(o)}catch(e){404!==e.response?.status&&(m.current+=1),m.current>=3&&(r({eventName:ne,payload:{status:"serviceFailure",provider:ue}}),clearInterval(n),c({funding:{...f,errorMessage:"Something went wrong adding funds from Moonpay. Please try again or use another method to fund your wallet."}}),i(d.FUNDING_METHOD_SELECTION_SCREEN))}}),3e3);return()=>clearInterval(n)}),[e,m]),n}const me={[f.id]:"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",[m.id]:"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",[y.id]:"0x0b2c639c533813f4aa9d7837caf62653d097ff85",[C.id]:"0x5fd84259d66Cd46123540766Be93DFE6D43130D7",[w.id]:"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",[E.id]:"0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",[b.id]:"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",[S.id]:"0x036CbD53842c5426634e7929541eC2318f3dCF7e",[T.id]:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",[A.id]:"0x5425890298aed601595a70ab815c96711a31bc65",[v.id]:"0xaf88d065e77c8cC2239327C5EDb3A432268e5831",[_.id]:"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d"},ye=({address:e,appConfig:t,fundWalletConfig:n,methodScreen:a,chainIdOverride:r,comingFromSendTransactionScreen:o=!1})=>{let i,c;if(!t.fundingConfig)throw Error("Wallet funding is not enabled");let l=de(t.fundingConfig.options);if(l.length<1)throw Error("Wallet funding is not enabled");i=r||(ge(n)&&n.chain?n.chain.id:le(t.fundingConfig.defaultRecommendedCurrency.chain));let d=t.chains.find((e=>e.id===i));if(!d)throw new s(`Funding chain ${i} is not in PrivyProvider chains list`);let u=ge(n)&&n.amount?n.amount:t.fundingConfig.defaultRecommendedAmount,h=!1;function p(){if(!i)return;let e=me[i];l.find((e=>"wallets"===e.method))&&!e&&console.warn("Attempting to fund with USDC on chain where USDC address is not known. Funding via external wallet will be disabled."),c=e,h=!0}ge(n)&&"asset"in n?"USDC"===n.asset?p():"string"!=typeof n.asset&&"erc20"in n.asset&&(h=((e,t)=>e===me[t.id])(c=n.asset.erc20,d)):"USDC"===t.fundingConfig.defaultRecommendedCurrency.asset&&p();let g=n?.defaultFundingMethod;return{chainType:"ethereum",address:e,amount:u,chain:d,erc20Address:c,erc20ContractInfo:h?{symbol:"USDC",decimals:6}:void 0,isUSDC:h,methodScreen:a,supportedOptions:l,comingFromSendTransactionScreen:o,defaultFundingMethod:g,usingDefaultFundingMethod:!!g,preferredCardProvider:n?.card?.preferredProvider,crossChainBridgingEnabled:t.fundingConfig.crossChainBridgingEnabled??!1,cluster:{name:"mainnet-beta",rpcUrl:t.solanaClusters["mainnet-beta"]},...pe(n)?{moonpayConfigOverride:n.config}:{},uiConfig:n&&"uiConfig"in n?n.uiConfig:void 0}};function Ce({address:e,fundWalletConfig:t,appConfig:n,comingFromSendTransactionScreen:a,methodScreen:s}){if(!n.fundingConfig)throw Error("Wallet funding is not enabled");let r=de(n.fundingConfig.options);if(r.length<1)throw Error("Wallet funding is not enabled");let o=t?.amount??n.fundingConfig.defaultRecommendedAmount,i=t?.defaultFundingMethod;return{chainType:"solana",address:e,supportedOptions:r,amount:o,isUSDC:!1,methodScreen:s,comingFromSendTransactionScreen:a,cluster:{name:t?.cluster?.name??"mainnet-beta",rpcUrl:n.solanaClusters[t?.cluster?.name??"mainnet-beta"]},crossChainBridgingEnabled:n.fundingConfig.crossChainBridgingEnabled??!1,defaultFundingMethod:i,preferredCardProvider:t?.card?.preferredProvider,usingDefaultFundingMethod:!!i,uiConfig:t?.uiConfig}}export{q as C,ne as O,$ as P,J as S,k as U,K as W,oe as a,ie as b,ce as c,he as d,M as e,B as f,fe as g,j as h,Y as i,te as j,de as k,z as l,se as m,ee as n,Ce as o,Q as p,ye as q,X as r,P as s,H as t,Z as u,le as v,L as w,re as x};
