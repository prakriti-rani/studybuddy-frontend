import{createAbstractClient as e}from"@abstract-foundation/agw-client";import{hexToNumber as n,createWalletClient as r,custom as a,http as t}from"viem";import{toAccount as i}from"viem/accounts";import{abstractTestnet as s}from"viem/chains";import{r as o,E as c,u as l,ab as d,M as p}from"./useWallets-DTpjk5Rk.mjs";import{u as m}from"./internal-context-mSHyF0Gq.mjs";import{a as E}from"./getPublicClient-wHgCncHx.mjs";import{g as u}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import{c as y}from"./smart-wallets-dP5AzE1-.mjs";import"viem/utils";import"react/jsx-runtime";import"react";import"tinycolor2";import"ofetch";import"permissionless";import"permissionless/accounts";import"permissionless/clients/pimlico";import"viem/account-abstraction";import"@privy-io/js-sdk-core";function g(){let{user:g}=o(),{hideWalletUIs:f,openPrivyModal:I,chains:T,appId:C,rpcConfig:N}=m(),{wallets:D}=c(),{setModalData:_}=l(),h=async(o=s.id)=>{let c=u(D);if(!c)throw Error("No connected wallet found");let l="string"==typeof o?n(o):o;if(![s.id,2741].includes(l))throw Error("Error, only Abstract chains are supported");let d=T.find((e=>e.id===l));if(!d)throw Error("Chain not configured");await c.switchChain(d.id);let p=await c.getEthereumProvider(),m=r({account:c.address,transport:a(p)}),y=i({address:c.address,signMessage:m.signMessage,signTransaction:m.signTransaction,signTypedData:m.signTypedData});return await e({chain:d,transport:t(E(d,N,C)),publicTransport:t(E(d,N,C)),signer:y})};return{signMessage:async({message:e},n)=>{let r=await h(n);return new Promise((async(n,a)=>{let{entropyId:t,entropyIdVerifier:i}=d(g);f.current=!0,_({connectWallet:{entropyId:t,entropyIdVerifier:i,onCompleteNavigateTo:p.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:e,confirmAndSign:()=>r.signMessage({message:e}),onSuccess:e=>n(e),onFailure:a,uiOptions:{isCancellable:!0}}}),I(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{f.current=!1}))},signTypedData:async(e,n)=>{let r=await h(n);return new Promise((async(n,a)=>{f.current=!0;let{entropyId:t,entropyIdVerifier:i}=d(g);_({connectWallet:{entropyId:t,entropyIdVerifier:i,onCompleteNavigateTo:p.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>r.signTypedData(e),onSuccess:e=>n(e),onFailure:a,uiOptions:{isCancellable:!0}}}),I(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{f.current=!1}))},sendTransaction:async e=>{let n=await h(e.chainId),r=[],a="calls"in e&&void 0!==e.calls;return r=a?[...e.calls]:[e],new Promise((async(t,i)=>{f.current=!0;let{entropyId:s,entropyIdVerifier:o}=d(g);_({connectWallet:{entropyId:s,entropyIdVerifier:o,onCompleteNavigateTo:p.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:y({calls:r,chain:n.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),entropyId:s,entropyIdVerifier:o,transactingWallet:{address:n.account.address,walletIndex:null},signOnly:!1,getIsSponsored:async()=>void 0!==e.paymaster&&void 0!==e.paymasterInput,onConfirm:()=>a?n.sendTransactionBatch(e):n.sendTransaction(e),onSuccess:e=>t(e.hash),onFailure:i,uiOptions:{isCancellable:!0}}}),I(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{f.current=!1}))},signTransaction:async e=>{let n=await h(e.chainId),r=[],a="calls"in e&&void 0!==e.calls;return r=a?[...e.calls]:[e],new Promise((async(t,i)=>{f.current=!0;let{entropyId:s,entropyIdVerifier:o}=d(g);_({connectWallet:{entropyId:s,entropyIdVerifier:o,onCompleteNavigateTo:p.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:y({calls:r,chain:n.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),entropyId:s,entropyIdVerifier:o,transactingWallet:{address:n.account.address,walletIndex:null},signOnly:!0,getIsSponsored:async()=>void 0!==e.paymaster&&void 0!==e.paymasterInput,onConfirm:()=>{if(!a)return n.signTransaction(e);throw Error("Batch transactions not supported for signing")},onSuccess:e=>t(e.hash),onFailure:i,uiOptions:{isCancellable:!0}}}),I(p.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{f.current=!1}))}}}export{g as useAbstractSmartWallets};
