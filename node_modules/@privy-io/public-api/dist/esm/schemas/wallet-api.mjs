import{z as t}from"zod";import{InvalidInputError as e,PrivyErrorCode as i}from"@privy-io/api-base";import{Pagination as a}from"./api.mjs";import{SolanaWalletAddress as o,WalletAddress as n}from"./core.mjs";import"bs58";import"libphonenumber-js/max";import"viem";const r=t.string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/,"Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'");let s=t.object({address:o.optional(),chain_type:t.literal("solana").optional()}),l=t.object({address:n.optional(),chain_type:t.literal("ethereum").optional()});const d=t.enum(["root","manager","delegated-actions"]).nullable(),c=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(s),h=t.object({method:t.literal("signAndSendTransaction"),caip2:r,params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(s),g=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")})}).merge(s);let m=t.string().startsWith("0x"),p=t.union([m,t.number()]);const _=t.object({from:n.optional(),to:n.optional(),chain_id:p.optional(),nonce:p.optional(),data:m.optional(),value:p.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:p.optional(),gas_price:p.optional(),max_fee_per_gas:p.optional(),max_priority_fee_per_gas:p.optional()}),b=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:_})}).merge(l),u=t.object({method:t.literal("eth_sendTransaction"),caip2:r,params:t.object({transaction:_})}).merge(l),j=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}),y=t.object({method:t.literal("personal_sign"),params:j}).merge(l),z=t.record(t.array(t.object({name:t.string(),type:t.string()}))),f=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:t.record(t.string(),t.any()),types:z,message:t.record(t.string(),t.any()),primary_type:t.string()})})}).merge(l),v=t.discriminatedUnion("method",[b,u,y,f]),I=t.discriminatedUnion("method",[c,h,g]),k=t.union([v,I]),x=t.object({method:t.literal("signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("base64")})}),A=t.object({method:t.literal("signAndSendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:r}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),T=t.object({method:t.literal("signMessage"),data:t.object({signature:t.string(),encoding:t.literal("base64")})}),D=t.object({method:t.literal("eth_signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("rlp")})}),w=t.object({method:t.literal("eth_sendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:r}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),U=t.object({method:t.literal("personal_sign"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),W=t.object({method:t.literal("eth_signTypedData_v4"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),C=t.discriminatedUnion("method",[x,A,T,D,w,U,W]),L=t.object({display_name:t.string().optional(),public_key:t.string(),role:d.optional()});let M=t.union([t.literal("solana"),t.literal("ethereum")]);const N=t.object({id:t.string(),address:t.string(),created_at:t.number(),chain_type:M,policy_ids:t.array(t.string()),authorization_threshold:t.number().optional()}),O=t.object({chain_type:M,policy_ids:t.array(t.string()).max(1).optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional()}).refine((t=>void 0===t.authorization_threshold||t.authorization_threshold>=1&&t.authorization_key_ids&&t.authorization_threshold<=t.authorization_key_ids.length),{message:"If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),S=t.object({id:t.string(),chain_type:M,address:t.string(),authorization_threshold:t.number().optional()}),V=t.object({wallet_id:t.string({required_error:"Wallet ID must be provided",invalid_type_error:"Wallet ID is not a valid string"}).min(1)}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),q=t.object({id:t.string()}),P=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),role:d,created_at:t.number()}),R=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),created_at:t.number()}),Z=a.extend({chain_type:M.optional()}),$=t.object({policy_ids:t.array(t.string()).max(1,"Only one policy ID can be set").optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional()}).strict().superRefine(((t,e)=>{Object.values(t).every((t=>null==t))&&e.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==t.authorization_threshold&&0!==t.authorization_threshold&&(t.authorization_threshold<0&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}),void 0===t.authorization_key_ids&&e.addIssue({code:"custom",path:["authorization_key_ids"],message:"An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."}),t.authorization_key_ids&&t.authorization_threshold>t.authorization_key_ids.length&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}))}));export{P as AuthorizationKeyDashboardResponse,R as AuthorizationKeyResponse,d as AuthorizationKeyRole,r as CAIP2,z as TypedDataTypesInputParams,_ as UnsignedEthereumTransaction,O as WalletApiCreateInput,S as WalletApiCreateResponse,y as WalletApiEthereumPersonalSignRpcInput,j as WalletApiEthereumPersonalSignRpcInputParams,U as WalletApiEthereumPersonalSignRpcResponse,v as WalletApiEthereumRpcInput,u as WalletApiEthereumSendTransactionRpcInput,w as WalletApiEthereumSendTransactionRpcResponse,b as WalletApiEthereumSignTransactionRpcInput,D as WalletApiEthereumSignTransactionRpcResponse,f as WalletApiEthereumSignTypedDataRpcInput,W as WalletApiEthereumSignTypedDataRpcResponse,L as WalletApiRegisterAuthorizationKeyInput,q as WalletApiRevokeAuthorizationKeyInput,k as WalletApiRpcInput,C as WalletApiRpcResponse,I as WalletApiSolanaRpcInput,h as WalletApiSolanaSignAndSendTransactionRpcInput,A as WalletApiSolanaSignAndSendTransactionRpcResponse,g as WalletApiSolanaSignMessageRpcInput,T as WalletApiSolanaSignMessageRpcResponse,c as WalletApiSolanaSignTransactionRpcInput,x as WalletApiSolanaSignTransactionRpcResponse,V as WalletIdFromPath,N as WalletResponse,$ as WalletUpdateInput,Z as WalletsSearchInput};
